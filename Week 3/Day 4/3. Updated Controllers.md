# Create Product and Order Controllers and their respective views in ASP.NET MVC

Here are the complete implementations of the `ProductController` and `OrderController` in an ASP.NET MVC application, utilizing dependency injection with Unity, the Unit of Work pattern, and services.

## ProductController

The `ProductController` manages CRUD operations for the `Product` entity. Create Empty Controller and then add the following code:

### ProductController.cs

```csharp
using System.Collections.Generic;
using System.Web.Mvc;
using SportStore.Models;
using SportStore.Services;

namespace SportStore.Controllers
{
    public class ProductController : Controller
    {
        private readonly IProductService _productService;

        public ProductController(IProductService productService)
        {
            _productService = productService;
        }

        // GET: Product
        public ActionResult Index()
        {
            IEnumerable<Product> products = _productService.GetAllProducts();
            return View(products);
        }

        // GET: Product/Details/5
        public ActionResult Details(int id)
        {
            Product product = _productService.GetProduct(id);
            if (product == null)
            {
                return HttpNotFound();
            }
            return View(product);
        }

        // GET: Product/Create
        public ActionResult Create()
        {
            return View();
        }

        // POST: Product/Create
        [HttpPost]
        [ValidateAntiForgeryToken]
        public ActionResult Create(Product product)
        {
            if (ModelState.IsValid)
            {
                _productService.CreateProduct(product);
                return RedirectToAction("Index");
            }
            return View(product);
        }

        // GET: Product/Edit/5
        public ActionResult Edit(int id)
        {
            Product product = _productService.GetProduct(id);
            if (product == null)
            {
                return HttpNotFound();
            }
            return View(product);
        }

        // POST: Product/Edit/5
        [HttpPost]
        [ValidateAntiForgeryToken]
        public ActionResult Edit(Product product)
        {
            if (ModelState.IsValid)
            {
                _productService.CreateProduct(product); // Update logic can be implemented
                return RedirectToAction("Index");
            }
            return View(product);
        }

        // GET: Product/Delete/5
        public ActionResult Delete(int id)
        {
            Product product = _productService.GetProduct(id);
            if (product == null)
            {
                return HttpNotFound();
            }
            return View(product);
        }

        // POST: Product/Delete/5
        [HttpPost, ActionName("Delete")]
        [ValidateAntiForgeryToken]
        public ActionResult DeleteConfirmed(int id)
        {
            _productService.DeleteProduct(id);
            return RedirectToAction("Index");
        }
    }
}
```

## OrderController

The `OrderController` manages CRUD operations for the `Order` entity. Create Empty Controller and then add the following code:

### OrderController.cs

```csharp
using System.Collections.Generic;
using System.Web.Mvc;
using SportStore.Models;
using SportStore.Services;

namespace SportStore.Controllers
{
    public class OrderController : Controller
    {
        private readonly IOrderService _orderService;

        public OrderController(IOrderService orderService)
        {
            _orderService = orderService;
        }

        // GET: Order
        public ActionResult Index()
        {
            IEnumerable<Order> orders = _orderService.GetAllOrders();
            return View(orders);
        }

        // GET: Order/Details/5
        public ActionResult Details(int id)
        {
            Order order = _orderService.GetOrder(id);
            if (order == null)
            {
                return HttpNotFound();
            }
            return View(order);
        }

        // GET: Order/Create
        public ActionResult Create()
        {
            return View();
        }

        // POST: Order/Create
        [HttpPost]
        [ValidateAntiForgeryToken]
        public ActionResult Create(Order order)
        {
            if (ModelState.IsValid)
            {
                _orderService.CreateOrder(order);
                return RedirectToAction("Index");
            }
            return View(order);
        }

        // GET: Order/Delete/5
        public ActionResult Delete(int id)
        {
            Order order = _orderService.GetOrder(id);
            if (order == null)
            {
                return HttpNotFound();
            }
            return View(order);
        }

        // POST: Order/Delete/5
        [HttpPost, ActionName("Delete")]
        [ValidateAntiForgeryToken]
        public ActionResult DeleteConfirmed(int id)
        {
            _orderService.DeleteOrder(id);
            return RedirectToAction("Index");
        }
    }
}
```

## Views:

- Create views for both `Products` and `Orders` Controllers.

## Key Components Overview

1. **Dependency Injection**: Both controllers receive their respective services through constructor injection, promoting loose coupling and easier testing.

2. **CRUD Operations**: Each controller implements methods for creating, reading, updating, and deleting (CRUD) products and orders. The actual update logic in the `Edit` methods can be implemented in a similar fashion to the `Create` method.

3. **Model Validation**: The `[ValidateAntiForgeryToken]` attribute is used to prevent CSRF attacks, and `ModelState.IsValid` checks if the model passed from the view is valid before proceeding with the operations.

4. **Redirection**: After successful operations, the controllers redirect to the index action to display the updated list.